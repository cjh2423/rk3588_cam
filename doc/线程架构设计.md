# 多线程架构设计与工作流详解

本文档详细描述了 `cam_demo` 项目的多线程异步架构。该架构旨在最大化利用 RK3588 的硬件资源（CPU、NPU、RGA），实现高帧率、低延迟的视频流处理与 AI 推理。

## 1. 系统核心线程模型

系统由三个主要线程并行工作，通过线程安全的队列进行数据交换。

| 线程名称 | 所属类 | 职责 | 关键特性 |
| :--- | :--- | :--- | :--- |
| **主线程 (UI Thread)** | `AppController` | 1. 业务调度中心<br>2. UI 界面刷新 (Qt)<br>3. 结果绘制 (Draw) | **轻量级**：不进行任何阻塞操作，确保界面响应极快。 |
| **预处理线程 (Producer)** | `PreprocessingThread` | 1. V4L2 摄像头采集<br>2. RGA 硬件加速 (翻转/缩放)<br>3. 图像预处理 (Letterbox) | **高吞吐**：独立于 UI 运行，保证采集帧率不受推理速度影响。 |
| **推理线程 (Consumer)** | `InferenceThread` | 1. 消费预处理图像<br>2. 执行 NPU 推理 (YOLOv8)<br>3. 后处理解算坐标 | **计算密集**：在后台运行，允许比采集速度慢，会自动丢帧。 |

## 2. 线程交互架构图 (ASCII 版)

```text
+-------------------------------------------------------+
|                 硬 件 层 (Hardware Layer)             |
|  [摄像头 V4L2]      [RGA 引擎]      [NPU 核心]        |
+-------------------------------------------------------+
       |                  ^               ^
       v                  |               |
+-------------------------|---------------|-------------+
| 1. 预处理线程 (Producer)|               |             |
|                         v               |             |
|   [m_camera.read] --> [process_with_rga]              |
|          |                      |                     |
+----------|----------------------|---------------------+
           |                      |
           v (生成 Task)          |
   [ 任务队列 (std::queue) ] <----+
           |
           v (取出 Task)
+-------------------------------------------------------+
| 2. 主线程 (Controller / UI Thread)                    |
|                                                       |
|   [onFrameTick 定时器触发]                            |
|          |                                            |
|          +----1. 获取最新图 (Fast Path) ----------+   |
|          |                                        |   |
|          +----2. 推送任务给 AI (非阻塞) --------+ |   |
|          |                                    | |   |
|          +----3. 取出 AI 坐标 (LatestResult) <| |-|-+ |
|          |                                    | | | |
|          v                                    v | | |
|   [drawResult 画框]                     [ 推送队列 ]| |
|          |                                    | | | |
|          v                                    | | | |
|   [updateFrame 显示]                          | | | |
+-----------------------------------------------|---|-|---+
                                                |   | |
                                                v   | |
+---------------------------------------------------|---|-+
| 3. 推理线程 (InferenceThread / Consumer)          |   | |
|                                                   |   | |
|   [等待任务] <------------------------------------+   | |
|       |                                               | |
|       v                                               | |
|   [yolov8_face_run (NPU)] ----------------------------+ |
|       |                                                 |
|       v                                                 |
|   [后处理坐标计算 (CPU)]                                |
|       |                                                 |
|       +------------------------------------------------>+
|                 (原子更新 m_latestResult)               |
+---------------------------------------------------------+
```

## 3. 详细时序逻辑 (解耦原理)

此图展示了一帧图像生命周期，以及为何“慢速推理”不会卡死“快速显示”。

```text
时间轴
  |
  |   [预处理线程]          [主线程 UI]            [推理线程]
  |        |                    |                      |
T1|   采集 Frame 1              |                      |
  |   RGA 处理 Frame 1          |                      |
  |        |                    |                      |
T2|   放入队列 ---------------->|                      |
  |                             |                      |
  |                       获取 Frame 1                 |
  |                       推给 AI -------------------->| 收到 Frame 1
  |                             |                      | 开始计算 (耗时 20-30ms)
  |                       叠加旧坐标 (Result 0)        | ...
  |                       渲染 Frame 1 (流畅!)         | ...
  |                             |                      | ...
T3|   采集 Frame 2              |                      | ...
  |   RGA 处理 Frame 2          |                      | ...
  |        |                    |                      | ...
T4|   放入队列 ---------------->|                      | ...
  |                             |                      | 算出 Result 1 (存入缓存)
  |                       获取 Frame 2                 |
  |                       推给 AI -------------------->| 收到 Frame 2
  |                             |                      |
  |                       获取最新坐标 (Result 1)      |
  |                       叠加新坐标 (Result 1)        |
  |                       渲染 Frame 2 (流畅!)         |
  v                             v                      v
```

## 4. 核心函数职责字典

### 4.1 `AppController` (src/app/app_controller.cc)

| 函数名 | 作用 | 调用关系 |
| :--- | :--- | :--- |
| **start** | 启动整个管线。加载模型路径，启动所有工作线程。 | Main -> start |
| **onFrameTick** | **业务引擎的心脏**。每 10ms 触发一次。负责将数据在 Pre/Inf/UI 之间搬运。 | QTimer -> onFrameTick |
| **drawResult** | **结果融合**。将最新的检测坐标使用 OpenCV 画在当前帧上。 | onFrameTick 内部调用 |

### 4.2 `PreprocessingThread` (src/app/preprocessing_thread.cc)

| 函数名 | 作用 | 调用关系 |
| :--- | :--- | :--- |
| **thread_func** | 线程主循环。以最快速度从摄像头取图。 | std::thread |
| **process_with_rga** | **硬件加速核心**。调用 `imflip_t` 和 `imresize_t`。 | thread_func 内部调用 |

### 4.3 `InferenceThread` (src/app/inference_thread.cc)

| 函数名 | 作用 | 调用关系 |
| :--- | :--- | :--- |
| **thread_loop** | 线程主循环。等待任务队列有数据后触发 NPU 推理。 | std::thread |
| **push_task** | 任务入口。如果队列满则丢弃旧帧，保证系统不产生累积延迟。 | Controller -> push_task |

## 5. 架构优势总结

1.  **高帧率 (High FPS)**: 主线程不等待 NPU，显示帧率仅取决于摄像头硬件限制。
2.  **低卡顿 (Zero Jitter)**: AI 推理的耗时波动被封装在独立线程中，不会导致 UI 界面“一卡一卡”。
3.  **负载均衡**: RGA 处理图像变换，NPU 处理神经网络，CPU 只做简单的逻辑调度，完美压榨 RK3588 性能。