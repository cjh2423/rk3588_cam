# 多线程架构设计与工作流详解

本文档详细描述了 `cam_demo` 项目的多线程异步架构。该架构旨在最大化利用 RK3588 的硬件资源（CPU、NPU、RGA），实现高帧率、低延迟的视频流处理与 AI 推理。

## 1. 系统核心线程模型

系统由四个主要线程并行工作，通过线程安全的队列进行数据交换。

| 线程名称 | 所属类 | 职责 | 关键特性 |
| :--- | :--- | :--- | :--- |
| **主线程 (UI Thread)** | `AppController` | 1. 业务调度中心<br>2. UI 界面刷新 (Qt)<br>3. 结果绘制 (Draw) | **轻量级**：不进行任何阻塞操作，确保界面响应极快。 |
| **预处理线程 (Producer)** | `PreprocessingThread` | 1. V4L2 摄像头采集<br>2. RGA 硬件加速 (翻转/缩放)<br>3. 图像预处理 (Letterbox) | **高吞吐**：独立于 UI 运行，保证采集帧率不受推理速度影响。 |
| **推理线程 (Consumer 1)** | `InferenceThread` | 1. 消费预处理图像<br>2. 执行 YOLOv8 NPU 推理 | **NPU 专用**：只负责重型计算，完成后立刻抛出结果，吞吐量极大。 |
| **后处理线程 (Consumer 2)** | `PostProcessThread` | 1. NMS 解算<br>2. FaceNet 特征提取 (NPU/CPU)<br>3. 数据库识别 | **流水线并行**：与 YOLO 推理并行执行，进一步降低系统总延迟。 |

## 2. 线程交互架构图 (ASCII 版)

```text
+-------------------------------------------------------+
|                 硬 件 层 (Hardware Layer)             |
|  [摄像头 V4L2]      [RGA 引擎]      [NPU 核心]        |
+-------------------------------------------------------+
       |                  ^               ^
       v                  |               |
+-------------------------|---------------|-------------+
| 1. 预处理线程 (Producer)|               |             |
|                         v               |             |
|   [m_camera.read] --> [process_with_rga]              |
|          |                      |                     |
+----------|----------------------|---------------------+
           |                      |
           v (生成 Task)          |
   [ 任务队列 (std::queue) ] <----+
           |
           v (取出 Task)
+-------------------------------------------------------+
| 2. 推理线程 (InferenceThread / YOLOv8)                |
|                                                       |
|   [等待任务] <----------------------------------------+
|       |                                               |
|       v                                               |
|   [yolov8_face_run (NPU)] ----------------------------+
|       |                                                 
|       v (Raw Output)                                    
|   [ 后处理队列 (std::queue) ]                           
+-------|-----------------------------------------------+ 
        |                                                 
        v                                                 
+-------------------------------------------------------+ 
| 3. 后处理线程 (PostProcessThread / NMS+FaceNet)       | 
|                                                       | 
|   [等待任务] <----------------------------------------+ 
|       |                                                 
|       v                                                 
|   [NMS + FaceNet + Database]                            
|       |                                                 
|       v                                                 
|   [ 原子更新 m_latestResult ]                           
+-------------------------------------------------------+
        ^
        | (读取结果)
+-------------------------------------------------------+
| 4. 主线程 (Controller / UI Thread)                    |
|                                                       |
|   [onFrameTick 定时器触发]                            |
|          |                                            |
|          +----1. 获取最新图 (Fast Path) --------------+
|          |                                            |
|          +----2. 提取并绘制结果 (LatestResult) -------+
|          |                                            |
|          v                                            |
|   [updateFrame 显示]                                  |
+-------------------------------------------------------+
```

## 3. 详细时序逻辑 (解耦原理)

此图展示了一帧图像生命周期，以及为何“慢速推理”不会卡死“快速显示”。

```text
时间轴
  |
  |   [预处理线程]          [主线程 UI]            [推理线程]
  |        |                    |                      |
T1|   采集 Frame 1              |                      |
  |   RGA 处理 Frame 1          |                      |
  |        |                    |                      |
T2|   放入队列 ---------------->|                      |
  |                             |                      |
  |                       获取 Frame 1                 |
  |                       推给 AI -------------------->| 收到 Frame 1
  |                             |                      | 开始计算 (耗时 20-30ms)
  |                       叠加旧坐标 (Result 0)        | ...
  |                       渲染 Frame 1 (流畅!)         | ...
  |                             |                      | ...
T3|   采集 Frame 2              |                      | ...
  |   RGA 处理 Frame 2          |                      | ...
  |        |                    |                      | ...
T4|   放入队列 ---------------->|                      | ...
  |                             |                      | 算出 Result 1 (存入缓存)
  |                       获取 Frame 2                 |
  |                       推给 AI -------------------->| 收到 Frame 2
  |                             |                      |
  |                       获取最新坐标 (Result 1)      |
  |                       叠加新坐标 (Result 1)        |
  |                       渲染 Frame 2 (流畅!)         |
  v                             v                      v
```

## 4. 核心函数职责字典

### 4.1 `AppController` (src/app/app_controller.cc)

| 函数名 | 作用 | 调用关系 |
| :--- | :--- | :--- |
| **start** | 启动整个管线。加载模型路径，启动所有工作线程。 | Main -> start |
| **onFrameTick** | **业务引擎的心脏**。每 10ms 触发一次。负责将数据在 Pre/Inf/UI 之间搬运。 | QTimer -> onFrameTick |
| **drawResult** | **结果融合**。将最新的检测坐标使用 OpenCV 画在当前帧上。 | onFrameTick 内部调用 |

### 4.2 `PreprocessingThread` (src/app/preprocessing_thread.cc)

| 函数名 | 作用 | 调用关系 |
| :--- | :--- | :--- |
| **thread_func** | 线程主循环。以最快速度从摄像头取图。 | std::thread |
| **process_with_rga** | **硬件加速核心**。调用 `imflip_t` 和 `imresize_t`。 | thread_func 内部调用 |

### 4.3 `InferenceThread` (src/app/inference_thread.cc)

| 函数名 | 作用 | 调用关系 |
| :--- | :--- | :--- |
| **thread_loop** | 线程主循环。等待任务队列有数据后触发 NPU 推理。 | std::thread |
| **push_task** | 任务入口。如果队列满则丢弃旧帧，保证系统不产生累积延迟。 | Controller -> push_task |

## 5. 架构优势总结

1.  **高帧率 (High FPS)**: 主线程不等待 NPU，显示帧率仅取决于摄像头硬件限制。
2.  **低卡顿 (Zero Jitter)**: AI 推理的耗时波动被封装在独立线程中，不会导致 UI 界面“一卡一卡”。
3.  **负载均衡**: RGA 处理图像变换，NPU 处理神经网络，CPU 只做简单的逻辑调度，完美压榨 RK3588 性能。